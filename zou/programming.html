<p>Programming is a cognatively hard activity. Similar to physically hard activities we need a proper amount of mental rewards to motivate us to pertake in these activities. These activities also take a tremendous amount of energy, and we experience fatigue. As such our bodies will signal us to slowdown as we fatigue.</p>
<p>In order to gain expertise in programming people should learn the programming language of choice, but also learn about the underlying computer system. The system includes both the hardware and the Operating System. As expertise is gained, programming becomes less of a struggle and more and more of a creative process. In my early days tracking down mysterious bugs was a very cumbersome process. I would find myself at times second guessing every aspect of my program and even at times think my computer is broken xD. As I gained knowledge and experience I can confidently zoom in to areas that might be at fault and eliminate areas which are unlikely to be the culprit. And view each bug as an opportunity which might lead me to learn something new.</p>
<p>Computer systems and programming languages are built on many layers of abstraction. Each layer turns mechanisms which are more complex to control to mechanisms which are easier to control. If you include the myriad of useful application programs to the many levels of abstraction that make up a computer system, the amount of detail which is incorporated in them is tremendous. It is the work of thousands if not tens of thousands of individuals. No one has indepth knowledge of everything (or even a large chunk) of all that modern computer systems has to offer. Anyone you meet who attempts to give you the impression that they do is likely a pretender to some degree. There are many of these people out there. Especially in the start-up scene, chasing VC money. If you meet someone that tells you the truth, which is that this technology is extremely complex and they only understand a small portion of it, and are always working to gain more understanding, then you might've just meet a real expert ;).</p>
<p>While at times programming is a very individualistic undertaking. The largest and most successful undertakings are all collaborative efforts. Among programmers I've meet with a reasonable amount of experience, there are two types who fall into mindsets which can become detrimental to a collaborative effort. Type I is the disgruntled programmer. They exude more negativity than others. Their state is not their own fault. They very likely gained their experience painstakingly and endured long isolated efforts which were not properly recognized and they were not properly respected considering their expertise. I believe its best to cheer these guys up as much as possible. To examine and recognize them for their hard work. And to make light any of their minor failings. Type II is an arrogant programmer. They believe their thoughts and ideas are not only the best, but sometimes they believe its the only way to construct software. And they can be stubborn about it. In reality there are many ways to construct software. x world class programmers will solve the same programming problem x different ways, each coming up with distinct solution which reflects their own creativity and individuality. Depending on the degree of their arrogance, this type should probably be avoided all together. I for one have not thought of any good ideas on how to incorporate them into a collaborative effort.</p>
<p>After thinking extensively about programming and computer systems I've begin to ascribe to the theory that life is deterministic. Its just too complex to determine and not undeterministic. This thought came to me as I am learning about multithreading. Application programmers view a multithreaded program as being scheduled non deterministically. Multithreaded programs which modify common memory without careful precautionary measure like mutual exclusive locking may produce non deterministic results. However for any program, if we take as input the state of the operating system and the state of every other process also running on the operating system, the output should be deterministic, its just too complex to determine.</p>
